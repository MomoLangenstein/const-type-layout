searchState.loadedDescShard("const_type_layout", 0, "CI Status MSRV Latest Version Rust Doc Crate Rust Doc Main …\nDiscriminant of an enum variant.\nAn enum type.\nDescriptor of the shallow layout of a field.\nMarker for whether the type is inhabited or uninhabited.\nThe type is inhabited, some value of type <code>T</code>.\nOptional value that exists if some other type is inhabited.\nA primitive type, e.g. <code>()</code>, <code>u8</code>, <code>*const i32</code>, <code>&amp;mut bool</code>, …\nA struct-like type, including unit structs, tuple structs, …\nShallow layout of the type.\nShallow layout of the type.\nUtility trait that provides the deep layout of a type.\nUtility trait that provides the shallow layout of a type.\nProvides the <code>#[derive(TypeLayout)]</code> implementation for the …\nDescription of the deep layout of a type.\nDescription of the shallow layout of a type.\nDescription of the shallow structure of a type.\nThe type is uninhabited, no value.\nA union type.\nDescription of the shallow layout of a variant\nThe type’s minimum alignment.\nReturns the logical and between <code>self</code> and <code>other</code>.\nThe variant’s descriminant, iff the variant is inhabited.\nHelper macro to construct a <code>Discriminant</code> from its constant …\nThe variant’s fields.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHash this <code>TypeLayoutGraph</code> using the provided <code>hasher</code>.\nHash this type’s <code>TypeLayoutGraph</code> using the provided <code>seed</code>.\nHelper module to compute whether a combination of types …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps a <code>MaybeUninhabited::Inhabited</code> to a …\nThe type’s fully-qualified name.\nThe variant’s name.\nThe field’s name.\nConstruct <code>MaybeUninhabited::Inhabited</code> iff …\nConstruct the deep type layout descriptor for a type <code>T</code>.\nThe field’s byte offset, iff the field is inhabited.\nReturns the or and between <code>self</code> and <code>other</code>.\nSerialise this <code>TypeLayoutGraph</code> into the mutable byte slice.\nSerialise this type’s <code>TypeLayoutGraph</code> into an array of …\nCompute the number of bytes that this <code>TypeLayoutGraph</code> …\nCompute the number of bytes that this type’s …\nThe type’s size.\nThe type’s shallow structure.\nThe type’s fully-qualified name.\nThe fully-qualified name of the field’s type. This is …\nHelper module to compute the set of types that a type …\nThe list of types that make up the complete graph …\nThe numeric value of the discriminant.\nThe fields of the struct.\nThe fields of the union.\nThe string representation of the type’s <code>#[repr(...)]</code> …\nThe string representation of the type’s <code>#[repr(...)]</code> …\nThe string representation of the type’s <code>#[repr(...)]</code> …\nThe variants of the union.\nHelper macro to compute whether\nHelper macro to compute whether\nComputes the set of types that a type links to.\nExtend the set <code>T</code> into a (larger) set containing also the …\nHelper macro to expand a list of types, e.g. <code>H, R1, R2</code>, …")