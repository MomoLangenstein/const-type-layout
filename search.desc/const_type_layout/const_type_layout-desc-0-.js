searchState.loadedDescShard("const_type_layout", 0, "CI Status MSRV Latest Version Rust Doc Crate Rust Doc Main …\nDiscriminant value of a type.\nThe type of the discriminant, which must satisfy the trait …\nAn enum type.\nHelper trait to extract the …\nDescriptor of the shallow layout of a field.\n<code>#[repr(i128)]</code> discriminant.\n<code>#[repr(i16)]</code> discriminant.\n<code>#[repr(i32)]</code> discriminant.\n<code>#[repr(i64)]</code> discriminant.\n<code>#[repr(i8)]</code> discriminant.\nMarker for whether the type is inhabited or uninhabited.\nThe type is inhabited, some value of type <code>T</code>.\n<code>#[repr(isize)]</code> discriminant (default).\nOptional value that exists if some other type is inhabited.\nA primitive type, e.g. <code>()</code>, <code>u8</code>, <code>*const i32</code>, <code>&amp;mut bool</code>, …\nA struct-like type, including unit structs, tuple structs, …\nShallow layout of the type.\nShallow layout of the type.\nUtility trait that provides the deep layout of a type.\nUtility trait that provides the shallow layout of a type.\nProvides the <code>#[derive(TypeLayout)]</code> implementation for the …\nDescription of the deep layout of a type.\nDescription of the shallow layout of a type.\nDescription of the shallow structure of a type.\n<code>#[repr(u128)]</code> discriminant.\n<code>#[repr(u16)]</code> discriminant.\n<code>#[repr(u32)]</code> discriminant.\n<code>#[repr(u64)]</code> discriminant.\n<code>#[repr(u8)]</code> discriminant.\nThe type is uninhabited, no value.\nA union type.\n<code>#[repr(usize)]</code> discriminant.\nDescription of the shallow layout of a variant\nThe type’s minimum alignment.\nReturns the logical and between <code>self</code> and <code>other</code>.\nThe variant’s descriminant, iff the variant is inhabited.\nThe variant’s fields.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHash this <code>TypeLayoutGraph</code> using the provided <code>hasher</code>.\nHash this type’s <code>TypeLayoutGraph</code> using the provided <code>seed</code>.\nHelper module to compute whether a combination of types …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps a <code>MaybeUninhabited::Inhabited</code> to a …\nThe type’s fully-qualified name.\nThe variant’s name.\nThe field’s name.\nConstruct <code>MaybeUninhabited::Inhabited</code> iff …\nConstruct the deep type layout descriptor for a type <code>T</code>.\nConstructs a <code>Discriminant</code> value with the given value <code>v</code> of …\nThe field’s byte offset, iff the field is inhabited.\nReturns the or and between <code>self</code> and <code>other</code>.\nSerialise this <code>TypeLayoutGraph</code> into the mutable byte slice.\nSerialise this type’s <code>TypeLayoutGraph</code> into an array of …\nCompute the number of bytes that this <code>TypeLayoutGraph</code> …\nCompute the number of bytes that this type’s …\nThe type’s size.\nThe type’s shallow structure.\nThe type’s fully-qualified name.\nThe fully-qualified name of the field’s type. This is …\nHelper module to compute the set of types that a type …\nThe list of types that make up the complete graph …\nThe fields of the struct.\nThe fields of the union.\nThe string representation of the type’s <code>#[repr(...)]</code> …\nThe string representation of the type’s <code>#[repr(...)]</code> …\nThe string representation of the type’s <code>#[repr(...)]</code> …\nThe variants of the union.\nHelper macro to compute whether\nHelper macro to compute whether\nComputes the set of types that a type links to.\nExtend the set <code>T</code> into a (larger) set containing also the …\nHelper macro to expand a list of types, e.g. <code>H, R1, R2</code>, …")